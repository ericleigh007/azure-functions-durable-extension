// Copyright (c) .NET Foundation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.

using Xunit.Abstractions;
using Xunit;
using System.Diagnostics;
using System.Net;

namespace Microsoft.Azure.Durable.Tests.DotnetIsolatedE2E;

[Collection(Constants.FunctionAppCollectionName)]
public class DistributedTracingEntitiesTests
{
    private readonly FunctionAppFixture _fixture;
    private readonly ActivityListener _activityListener;

    public DistributedTracingEntitiesTests(FunctionAppFixture fixture, ITestOutputHelper testOutputHelper)
    {
        _fixture = fixture;
        _fixture.TestLogs.UseTestLogger(testOutputHelper);

        // Initialize the ActivityListener here
        _activityListener = new ActivityListener
        {
            ShouldListenTo = source => source.Name == "DistributedTracingEntitiesTests",
            Sample = (ref ActivityCreationOptions<ActivityContext> _) => ActivitySamplingResult.AllDataAndRecorded,
            ActivityStarted = activity => { /* Handle activity started */ },
            ActivityStopped = activity => { /* Handle activity stopped */ }
        };
        ActivitySource.AddActivityListener(_activityListener);
    }

    /// <summary>
    /// At this point, since there seems to be no way to capture the Activities generated by interacting with entities without writing our own custom OpenTelemetry Collector,
    /// we will just attempt to verify that the Activities we can see via "Activity.Current" from within the entities and orchestrations calling them have the same trace ID. 
    /// </summary>
    [Fact]
    [Trait("MSSQL", "Skip")] // Entities are not implemented for the MSSQL backend
    [Trait("DTS", "Skip")] // Distributed tracing is currently not working in DTS
    [Trait("PowerShell", "Skip")] // Neither distributed tracing nor entities are currently implemented in PowerShell
    [Trait("Python", "Skip")] // Distributed tracing is not currently implemented in Python
    [Trait("Node", "Skip")] // Distributed tracing is not currently implemented in Node
    [Trait("Java", "Skip")] // Neither distributed tracing nor entities are currently implemented in Java
    public async Task DistributedTracingEntitiesTest()
    {
        // Start an Activity here which will appear as the root of all other Activities generated by this test
        ActivitySource activitySource = new ActivitySource("DistributedTracingEntitiesTests");
        using Activity? activity = activitySource.StartActivity("OrchestrationTests");

        Assert.NotNull(activity);

        using HttpResponseMessage response = await HttpHelpers.InvokeHttpTrigger("StartOrchestration", "?orchestrationName=DistributedTracingEntitiesOrchestration");

        string statusQueryGetUri = await DurableHelpers.ParseStatusQueryGetUriAsync(response);
        await DurableHelpers.WaitForOrchestrationStateAsync(statusQueryGetUri, "Completed", 30);
        var orchestrationDetails = await DurableHelpers.GetRunningOrchestrationDetailsAsync(statusQueryGetUri);

        // Sanitize the JSON string to remove unwanted characters so we can easily parse it into a list
        var output = orchestrationDetails.Output.Replace("\r", "").Replace("\n", "").Replace("\"", "").Replace("[", "").Replace("]", "").Replace(" ", "");
        var ids = new List<string>(output.Split(","));

        // The execution is as follows:
        // Orchestration A signals entity A which signals entity B. Then orchestration A calls entities A and B. Finally orchestration A signals entity C.
        // Entity C starts orchestration B which calls entity A again. 
        // Overall, we expect 8 Activities to be created - one by orchestration A, one by orchestration B, three by entity A, two by entity B, and one by entity C.
        // Orchestration A and B return this list of Activities as part of their output. In order to access the output of orchestration B, we need to return its
        // instance ID as part of the output of orchestration A. It will be the last item in the list returned by A, so we will remove it from the list and use it
        // to get the output of orchestration B (which will have the final two Activities, that for orchestration B and its call to entity A).
        Assert.Equal(7, ids.Count);
        var orchestrationId = ids[ids.Count - 1];
        ids.RemoveAt(ids.Count - 1);

        HttpResponseMessage result = await HttpHelpers.InvokeHttpTrigger("GetActivityInfoOrchestration_Output", $"?id={orchestrationId}");
        Assert.Equal(HttpStatusCode.OK, result.StatusCode);
        var remainingIds = (await result.Content.ReadAsStringAsync()).Replace("\r", "").Replace("\n", "").Replace("\"", "").Replace("[", "").Replace("]", "").Replace(" ", "");
        ids.AddRange(remainingIds.Split(","));
        Assert.Equal(8, ids.Count);
        Assert.True(ids.All(traceId => traceId.Equals(activity.TraceId.ToString())));
    }

    [Fact]
    [Trait("MSSQL", "Skip")] // Entities are not implemented for the MSSQL backend
    [Trait("DTS", "Skip")] // Distributed tracing is currently not working in DTS
    [Trait("PowerShell", "Skip")] // Neither distributed tracing nor entities are currently implemented in PowerShell
    [Trait("Python", "Skip")] // Distributed tracing is not currently implemented in Python
    [Trait("Node", "Skip")] // Distributed tracing is not currently implemented in Node
    [Trait("Java", "Skip")] // Neither distributed tracing nor entities are currently implemented in Java
    public async Task DistributedTracingEntitiesFromClientTest()
    {
        // Start an Activity here which will appear as the root of all other Activities generated by this test
        ActivitySource activitySource = new ActivitySource("DistributedTracingEntitiesTests");
        using Activity? activity = activitySource.StartActivity("ClientTests");

        Assert.NotNull(activity);

        // We need to reset the state of the entities before running the test to removed any stored trace IDs
        using HttpResponseMessage resetResponse = await HttpHelpers.InvokeHttpTrigger("StartOrchestration", "?orchestrationName=ResetStateOrchestration");
        string statusQueryGetUri = await DurableHelpers.ParseStatusQueryGetUriAsync(resetResponse);
        await DurableHelpers.WaitForOrchestrationStateAsync(statusQueryGetUri, "Completed", 30);

        await HttpHelpers.InvokeHttpTrigger("SignalActivityRecorderEntity", "");
        using HttpResponseMessage getActivityInfosResponse = await HttpHelpers.InvokeHttpTrigger("StartOrchestration", "?orchestrationName=GetMainAndSecondaryActivityInfoOrchestration");
        statusQueryGetUri = await DurableHelpers.ParseStatusQueryGetUriAsync(getActivityInfosResponse);
        await DurableHelpers.WaitForOrchestrationStateAsync(statusQueryGetUri, "Completed", 30);
        var orchestrationDetails = await DurableHelpers.GetRunningOrchestrationDetailsAsync(statusQueryGetUri);

        // Sanitize the JSON string to remove unwanted characters so we can easily parse it into a list
        var output = orchestrationDetails.Output.Replace("\r", "").Replace("\n", "").Replace("\"", "").Replace("[", "").Replace("]", "").Replace(" ", "");
        var ids = new List<string>(output.Split(","));

        // The execution is as follows:
        // Client signals entity A which signals entity B. 
        // The orchestration then calls entities A and B and aftewards resets their state.
        // We expect 5 Activities to be created - one by the orchestration, two by entity A, and two by entity B.
        Assert.Equal(5, ids.Count);
        Assert.True(ids.All(traceId => traceId.Equals(activity.TraceId.ToString())));
    }
}
